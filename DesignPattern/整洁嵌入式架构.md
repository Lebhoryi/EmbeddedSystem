# 软件架构设计

- 一个好的架构，不仅要在某一特定时刻满足软件用户、开发者和所有者的需求，更要在一段时间内持续满足他们的后续需求。
- 软件架构没有固定的展现形式，每一个视图都是架构师所做的层层抉择。
- 所谓软件架构，就是你希望在项目一开始就能做对，但是却不一定能够做得对的决策的集合。
- 软件架构规则和其他变量完全无关。
- 底层设计细节和高层架构信息是不可分割的，他们组合在一起，共同定义了整个软件系统，缺一不可。所谓底层和高层本身就是一系列决策组成的连续体，并没有清晰的分界线。
- 软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。（所以考虑维护成本是很重要的）
- 要想跑得快，先要跑的稳。
- 软件架构师必须创建出一个可以让功能实现起来更容易、修改起来更简单、扩展起来更轻松的软件架构。
- 结构化编程赋予了我们创造可证伪程序单元的能力，这就是为什么现代编程语言一般不支持无限制的 `goto` 语句。因此在架构设计领域，功能性讲解拆分仍然是最佳实践之一。

## 整洁的嵌入式架构

### 编写软件而不是编写固件

虽然软件本身并不会随着时间推移而磨损，但硬件及其固件却会随时间推移而过时，随即也需要对软件做相应改动。其中软件（software）应该是一种使用周期很长的东西，而固件（firmware）则会随着硬件演进而淘汰过时。

固件不是依据其存储的位置来定义的，而是由其代码的依赖关系，及其随着硬件的演进在变更难度上的变化来定义的。硬件的演进是显而易见的，我们在架构嵌入式代码时要时刻记住这一点。

要时刻记住 **编写软件而不是编写固件。**

### 程序适用性测试

为什么这么多嵌入式软件最后都成了固件？看起来，很可能是因为我们在做嵌入式设计时只关注代码能否顺利运行，并不太关心其结构能否撑起一个较长的有效生命周期。Kent Beck 描述了软件构建过程中的三个阶段：

1. “先让代码工作起来”——如果代码不能工作，就不能产生价值。
2. “然后再试图将它变好——通过对代码进行重构，让我们自己和其他人更好地理解代码，并能按照需求不断地修改代码。
3. “最后再试着让它运行得更快”——按照性能提升的“需求”来重构代码。

对于程序员来说，让他的程序工作这件事只能被称为“程序适用测试（app-titude test）”。一个程序员，不论他写的是否是嵌入式程序，如果目标仅仅是让程序可以工作，恐怕对他的老板和这个程序本身而言都是一件坏事。毕竟，编程这件事可远不止是让程序可以工作这么简单。

代码能够正确工作，只是对程序最基本的要求，并不能说该应用程序有一套整洁的嵌入式结构。

## 目标硬件瓶颈

### 整洁的嵌入式架构就是可测试的嵌入式架构

### Layers 分层

### 硬件是实现细节

### 不要向 HAL 的用户暴露硬件细节

依照整洁的嵌入式架构所构建的软件应该是可以脱离目标硬件平台来进行测试的。因为设计合理的 HAL 可以为我们脱离硬件平台的测试提供相应的支撑。

### 处理器是实现细节

### 操作系统是实现细节

### 面向接口编程与可替代性

除了在嵌入式系统的主要分层（指软件、操作系统、固件、硬件这四层）之中增加 HAL 和 OSAL 之外，我们还可以——也应该——应用本书中提到的其他设计原则。这些设计原则可以帮助我们按功能模块、接口编程以及可替代性来划分系统。

分层架构的理念是基于接口编程的理念来设计的。当模块之间能以接口形式交互时，我们就可以将一个服务替换成另外一个服务。例如，很多读者应该都写过能在某个目标机器上运行的、小型的自定义的 `printf` 函数。只要我们的 `printf` 与标准的 `printf` 函数接口一致，它们就可以互相替换。

目前的普适规则之一就是用头文件来充当接口的定义。然而，如果真的要这样做的话，就需要小心控制头文件中的内容，尽量确保头文件中只包括函数声明，以及函数所需要的结构体名字和常量。

另外，不要在定义接口的头文件中包含只有具体实现代码才需要的数据结构、常量以及类型定义（typedef）。这不仅仅是架构是否整洁的问题，而是这样做可能会导致意外的依赖关系。总之，我们必须控制好实现细节的可见性，因为这些实现细节是肯定会变化的。关注实现细节的代码越少，它们所需的变更就越少。

由整洁的嵌入式架构所构建的系统应该在每一个分层中都是可测试的，因为它的模块之间采用接口通信，每一个接口都为平台之外的测试提供了替换点。

### 条件性编译命令

另一个经常被忽视的可替代换性规则的实际案例是嵌入式 C/C++ 程序对不同平台和操作系统的处理方式。这些程序经常会用条件性编译命令来根据不同的平台启用和禁用某一段代码。例如，我曾经遇到过 `#ifdef BOARD_V2` 这条语句在一个电信应用程序中出现了几千次的情况。

很显然，这种代码的重复违背了“不要重复自己（DRY）”原则。如果 `#ifdef BOARD_V2` 只出现一次，这当然不是什么问题，而如果出现了 6000 次，那就非常严重了。但这类条件性编译语句在嵌入式编程中非常常见，有什么好的解决方案吗？

使用硬件抽象层如何？这样的话，硬件类型就只是 HAL 中的一个实现细节了。而且，如果系统中使用的是 HAL 所提供的一系列接口，而不是条件性编译语句，那么我们就可以用链接器，或者某种运行时加载器来将软件与硬件相结合了。

### 总结

嵌入式编程人员应该多学习一些非嵌入式系统的编程经验。

为了让我们的产品能长期地保持健康，请别让你的代码都变成固件。如果一个系统的代码只能在目标硬件上测试，那么它的开发过程会变得非常艰难。总之，为产品的长期健康着想而采用一套整洁的嵌入式架构是很有必要的。
